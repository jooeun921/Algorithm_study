# [Gold V] LCS - 9251 '⭐⭐⭐'❣️'

[문제 링크](https://www.acmicpc.net/problem/9251) 

### 성능 요약

메모리: 56604 KB, 시간: 444 ms

### 분류

다이나믹 프로그래밍, 문자열

### 제출 일자

2025년 3월 28일 22:54:17

### 문제 설명

<p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p>

<p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p>

### 입력 

 <p>첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.</p>

### 출력 

 <p>첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.</p>

### 메모

- **문제 핵심**: 두 문자열 A와 B의 **최장 공통 부분 수열(LCS)**의 길이를 구하는 문제입니다.
- **LCS 정의**:
  - LCS는 두 문자열에서 순서를 유지하면서 공통으로 나타나는 가장 긴 부분 수열입니다.
  - 예: A = "ACAYKP", B = "CAPCAK"일 때, LCS는 "ACAK"이며 길이는 4입니다.

---

- **알고리즘**:
  - **동적 프로그래밍(DP)**를 사용하여 LCS를 계산합니다.
  - `dp[i][j]`는 A의 첫 `i`글자와 B의 첫 `j`글자 사이의 LCS 길이를 저장합니다.
  - 점화식:
    1. **문자가 같을 때**: `dp[i][j] = dp[i-1][j-1] + 1`
       - 현재 문자가 공통이므로 이전 상태에서 1을 더합니다.
    2. **문자가 다를 때**: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
       - 현재 문자가 공통이 아니므로, 이전 상태 중 더 큰 값을 선택합니다.

---

- **구현 과정**:
  1. 문자열 A와 B의 길이를 각각 `m`과 `n`으로 설정합니다.
  2. `dp` 테이블을 `(m+1) x (n+1)` 크기로 초기화합니다.
     - `dp[0][j]`와 `dp[i][0]`은 0으로 초기화 (공집합과의 비교).
  3. 이중 반복문을 통해 `dp` 테이블을 채웁니다:
     - `i`는 문자열 A의 인덱스, `j`는 문자열 B의 인덱스.
     - 각 위치에서 위의 점화식을 적용합니다.
  4. 최종 결과는 `dp[m][n]`에 저장됩니다.

---

- **시간 복잡도**:
  - 이중 반복문을 사용하므로 시간 복잡도는 **O(m × n)**입니다.
  - `m`과 `n`은 문자열 A와 B의 길이입니다.

- **공간 복잡도**:
  - `dp` 테이블의 크기는 `(m+1) x (n+1)`이므로 공간 복잡도는 **O(m × n)**입니다.
  - 최적화를 통해 1차원 배열로 줄일 수도 있습니다.

---

- **예제**:
  - 입력:
    ```
    ACAYKP
    CAPCAK
    ```
  - 출력:
    ```
    4
    ```
  - 설명:
    - LCS는 "ACAK"이며, 길이는 4입니다.